# 36. 有效的数独

## 题目链接
[https://leetcode-cn.com/problems/valid-sudoku/](https://leetcode-cn.com/problems/valid-sudoku/)

## 题目描述
判断一个 9x9 的数独是否有效。只需要根据以下规则，验证已经填入的数字是否有效即可。

 - 数字 1-9 在每一行只能出现一次。
 - 数字 1-9 在每一列只能出现一次。
 - 数字 1-9 在每一个以粗实线分隔的 3x3 宫内只能出现一次。

数独部分空格内已填入了数字，空白格用 '.' 表示。

示例1：
```
输入:
[
  ["5","3",".",".","7",".",".",".","."],
  ["6",".",".","1","9","5",".",".","."],
  [".","9","8",".",".",".",".","6","."],
  ["8",".",".",".","6",".",".",".","3"],
  ["4",".",".","8",".","3",".",".","1"],
  ["7",".",".",".","2",".",".",".","6"],
  [".","6",".",".",".",".","2","8","."],
  [".",".",".","4","1","9",".",".","5"],
  [".",".",".",".","8",".",".","7","9"]
]
输出: true
```

示例2：
```
输入:
[
  ["8","3",".",".","7",".",".",".","."],
  ["6",".",".","1","9","5",".",".","."],
  [".","9","8",".",".",".",".","6","."],
  ["8",".",".",".","6",".",".",".","3"],
  ["4",".",".","8",".","3",".",".","1"],
  ["7",".",".",".","2",".",".",".","6"],
  [".","6",".",".",".",".","2","8","."],
  [".",".",".","4","1","9",".",".","5"],
  [".",".",".",".","8",".",".","7","9"]
]
输出: false
解释: 除了第一行的第一个数字从 5 改为 8 以外，空格内其他数字均与 示例1 相同。
     但由于位于左上角的 3x3 宫内有两个 8 存在, 因此这个数独是无效的。
```

说明:

 - 一个有效的数独（部分已被填充）不一定是可解的。
 - 只需要根据以上规则，验证已经填入的数字是否有效即可。
 - 给定数独序列只包含数字 1-9 和字符 '.' 。
 - 给定数独永远是 9x9 形式的。

## 思路1：哈希映射
 - 使用哈希集合保存每一行、每一列、每个九宫格内数字的出现次数
 - 遍历数独，更新哈希集合，如果当前行、列或九宫格内的当前数字出现次数超过一次，说明数独不合法
 - 遍历完整个数独，每一行、每一列、每个九宫格内数字出现次数均不超过一次，说明数独合法


#### 代码
```java
class Solution {
    public boolean isValidSudoku(char[][] board) {
        // row[i]保存第i行每个数字出现的次数
        HashMap<Integer, Integer>[] row = new HashMap[9];
        // col[j]保存第j列每个数字出现的次数
        HashMap<Integer, Integer>[] col = new HashMap[9];
        // square[squareIdx]保存第squareIdx个九宫格每个数字出现的次数
        HashMap<Integer, Integer>[] square = new HashMap[9];

        // 初始化
        for(int i = 0; i < 9; i++){
            row[i] = (new HashMap<Integer, Integer>());
            col[i] = (new HashMap<Integer, Integer>());
            square[i] = (new HashMap<Integer, Integer>());
        }

        // 遍历数独
        for(int i = 0; i < 9; i ++){
            for(int j = 0; j < 9; j++){
                char c = board[i][j];
                // 遍历到数字
                if( c != '.' ){
                    // char -> int
                    int num = c - '0';
                    // 九宫格索引
                    int squareIdx = (i / 3 * 3) + j / 3;

                    // 更新行、列、九宫格数字出现次数
                    row[i].put(num, row[i].getOrDefault(num, 0) + 1);
                    col[j].put(num, col[j].getOrDefault(num, 0) + 1);
                    square[squareIdx].put(num, square[squareIdx].getOrDefault(num, 0) + 1);

                    // 如果当前数字在当前行、列、九宫格出现次数超过一次，则数独不合法
                    if( row[i].get(num) > 1||  col[j].get(num) > 1 ||  square[squareIdx].get(num) > 1 ){
                        return false;
                    }
                }
            }
        }
        return true;
    }
}
```

#### 复杂度分析
 - 时间复杂度 O(1) ：对81个单元格进行了迭代，每个单元格操作的时间复杂度是 O(1)，因此总的时间复杂度是 O(81) = O(1)
 - 空间复杂度 O(1) ：空间复杂度与输入无关，需要27个哈希表保存9行、9列、9个九宫格内数字1-9的出现次数

#### 思路2：位运算优化
 - 基于思路1，改用数字 num 保存每一行、每一列、每个九宫格内数字是否出现过
 - 对于行 row[i]，如果 num 的二进制表示的第一位是1，则表示第 i 行出现过数字 1，列、九宫格同理
 - 遍历数独，检查当前行、列、九宫格是否出现过当前数字；如果出现过，说明数独不合法；如果没出现过，标记当前行、列、九宫格出现过当前数字
 - 遍历完整个数独，每一行、每一列、每个九宫格内数字出现次数均不超过一次，说明数独合法

#### 代码
```java
class Solution {
    int[] row = new int[9];
    int[] col = new int[9];
    int[][] square = new int[3][3];

    public boolean isValidSudoku(char[][] board) {
        // 遍历数独
        for(int i = 0; i < 9; i ++){
            for(int j = 0; j < 9; j++){
                char c = board[i][j];
                // 遍历到数字
                if( c != '.' ){
                    // char -> int
                    int num = c - '0';
                    if( check(i, j, num) == false ){
                        return false;
                    }
                }
            }
        }
        return true;
    }

    public boolean check(int i, int j, int num){
        // 最低位表示数字1是否出现过，次低位表示数字2是否出现过，依此类推
        int pos = 1 << (num - 1);

        // 如果当前数字在当前行、列、九宫格已经出现过，说明数独不合法
        if( (row[i] & pos) != 0 || (col[j] & pos) != 0 || (square[i / 3][j / 3] & pos) != 0 ){
            return false;
        }

        // 标记当前行、列、九宫格出现过当前数字
        row[i] |= pos;
        col[j] |= pos;
        square[i / 3][j / 3] |= pos;
        return true;
    }
}
```

#### 复杂度分析
 - 时间复杂度 O(1) ：对81个单元格进行了迭代，每个单元格操作的时间复杂度是 O(1)，因此总的时间复杂度是 O(81) = O(1)
 - 空间复杂度 O(1) ：空间复杂度与输入无关，需要27个数字保存9行、9列、9个九宫格内数字1-9的出现次数
