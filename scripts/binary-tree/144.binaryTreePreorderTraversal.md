# 144. 二叉树的前序遍历

## 题目链接
[https://leetcode-cn.com/problems/binary-tree-preorder-traversal/](https://leetcode-cn.com/problems/binary-tree-preorder-traversal/)

## 题目描述
给你二叉树的根节点 root ，返回它节点值的 前序 遍历。

示例1：
```
输入：root = [1,null,2,3]
输出：[1,2,3]
```

示例2：
```
输入：root = []
输出：[]
```

示例3：
```
输入：root = [1]
输出：[1]
```

示例4：
```
输入：root = [1,2]
输出：[1,2]
```

示例5：
```
输入：root = [1,null,2]
输出：[1,2]
```

提示：

 - 树中节点数目在范围 [0, 100] 内
 - -100 <= Node.val <= 100
 

进阶：递归算法很简单，你可以通过迭代算法完成吗？

## 思路1：递归

#### 代码
```javascript
var preorderTraversal = function(root) {
    const ans = [];
    dfs(root, ans);
    return ans;
};

function dfs(node, ans){
    if( node === null ){
        return;
    }
    ans.push(node.val);
    dfs(node.left, ans);
    dfs(node.right, ans);
}
```

#### 复杂度分析
 - 时间复杂度 O(n) ：n 是二叉树的节点数目。每个节点被访问一次
 - 空间复杂度 O(n) ：n 是二叉树的节点数目。空间复杂度取决于递归的深度；最坏的情况下，二叉树呈链状，树的高度是 n ，递归调用的层数是 n ，因此空间复杂度是 O(n)

## 思路2：迭代
 - 使用栈模拟思路1的递归操作

#### 代码
```javascript
var preorderTraversal = function(root) {
    const ans = [];
    // 特殊情况：二叉树为空
    if( root === null ){
        return ans;
    }
    const stack = [];
    // 初始时，根节点入栈
    stack.push(root);
    while( stack.length ){
        let node = stack.pop();
        ans.push(node.val);
        if( node.right !== null ){
            stack.push(node.right);
        }
        if( node.left !== null ){
            stack.push(node.left);
        }
    }
    return ans;
};
```

#### 复杂度分析
 - 时间复杂度 O(n) ：n 是二叉树的节点数目。每个节点被访问一次，入栈、出栈一次
 - 空间复杂度 O(n) ：n 是二叉树的节点数目。空间复杂度取决于栈的大小，栈中只需要保存每一层的一个节点，因此平均情况下的空间复杂度是 O(log(n)) ；最坏的情况下，除根节点外所在层外每一层只有两个节点，空间复杂度是 O(n / 2) = O(n) 。因此空间复杂度是 O(n)
