# 127. 单词接龙

## 题目链接
[https://leetcode-cn.com/problems/word-ladder/](https://leetcode-cn.com/problems/word-ladder/)

## 题目描述
字典 wordList 中从单词 beginWord 和 endWord 的 转换序列 是一个按下述规格形成的序列：

 - 序列中第一个单词是 beginWord 。
 - 序列中最后一个单词是 endWord 。
 - 每次转换只能改变一个字母。
 - 转换过程中的中间单词必须是字典 wordList 中的单词。

给你两个单词 beginWord 和 endWord 和一个字典 wordList ，找到从 beginWord 到 endWord 的 最短转换序列 中的 单词数目 。如果不存在这样的转换序列，返回 0。

示例1：
```
输入：beginWord = "hit", endWord = "cog", wordList = ["hot","dot","dog","lot","log","cog"]
输出：5
解释：一个最短转换序列是 "hit" -> "hot" -> "dot" -> "dog" -> "cog", 返回它的长度 5。
```

示例2：
```
输入：beginWord = "hit", endWord = "cog", wordList = ["hot","dot","dog","lot","log"]
输出：0
解释：endWord "cog" 不在字典中，所以无法进行转换。
```

提示：

 - 1 <= beginWord.length <= 10
 - endWord.length == beginWord.length
 - 1 <= wordList.length <= 5000
 - wordList[i].length == beginWord.length
 - beginWord、endWord 和 wordList[i] 由小写英文字母组成
 - beginWord != endWord
 - wordList 中的所有字符串 互不相同

## 思路1：广度优先搜索
 - 遍历字典 wordList ，记录能由 beginWord 一次转换获得的单词
 - 循环查找这些单词经一次转换能够获得的单词，直至查找到 endWord 或无法继续转换
 - 为了防止重复查找，使用集合记录查找过的单词

#### 代码
```javascript
/**
 * @param {string} beginWord
 * @param {string} endWord
 * @param {string[]} wordList
 * @return {number}
 */
 var ladderLength = function(beginWord, endWord, wordList) {
    // 字典中不存在 endWord
    if( !wordList.includes(endWord) ){
        return 0;
    }

    const visited = new Set();
    let curWordList = [beginWord];
    let distance = 1;
    while(curWordList.length){
        distance++;
        // 查找下一次转换的单词
        const nextWordList = [];
        for(const curWord of curWordList){
            for(const word of wordList){
                if( !visited.has(word) && match(curWord, word) ){
                // 查找到 endWord
                    if(word === endWord){
                        return distance;
                    }
                    visited.add(word);
                    nextWordList.push(word);
                }
            }
        }
        curWordList = nextWordList;
    }
    return 0;
};

/**
 * 判断 word1 和 word2 能否相互转换
**/
function canTransform(word1, word2){
    let mathCharNum = 0;
    const len = word1.length;
    for(let i = 0; i < len; i++){
        if( word1[i] === word2[i] ){
            mathCharNum++;
        }
    }
    return mathCharNum === len - 1;
}
```

#### 复杂度分析
 - 时间复杂度 O(L * n<sup>2</sup>) ：n 是字典 wordList 的长度，L 是单词的长度。查找一个单词能转换单词的时间复杂度是 O(L * n) ，最多需要查找 n 个单词能转换的单词，因此时间复杂度是 O(L * n<sup>2</sup>)。
 - 空间复杂度 O(L * n) ：n 是字典 wordList 的长度，L 是单词的长度。数组 curWordList 、nextWordList 和集合 visited 内的单词数量不会超过 n 个，每个单词的长度是 l 。因此，总的空间复杂度是 O(n * L)